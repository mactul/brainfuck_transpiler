MEMORY_SIZE = 100


def smallest_square(n: int):
    """
    returns the smallest int square that correspond to a integer
    example: smallest_square(65) returs 8 (8*8 = 64)
    """
    n = abs(n)
    i = 0
    while i**2 <= n:
        i += 1
    if n - (i-1)**2 < i**2 - n:
        return i - 1
    else:
        return i


def smallest_multiples(n: int):
    """
    Returns a couple of intersions who when they are multiplied between them approaches the number n
    example: smallest_multiples(55) returns (8, 7) because 8*7=56
    """
    if n < 0:
        sign = -1
        n *= - 1
    else:
        sign = 1
    i = smallest_square(n)
    a = i
    while abs(i**2 - n) > abs(i * (a-1) - n):
        a -= 1
    while abs(i**2 - n) > abs(i * (a+1) - n):
        a += 1
    return a, i * sign


def string_to_bf(string: str):
    """
    transform a string in ascii to code in brainfuck
    """
    result = ""  # output string
    p = 0  # value of the current byte
    for i in string:
        a = ord(i) - p  # how much must add to the byte

        if abs(a) <= 7:  # it is more interesting to put full "+" than to make a loop
            if a < 0:
                char = "-"
            else:
                char = "+"
            result = result[:-1] + char * abs(a) + ".<"
        else:
            x, y = smallest_multiples(a)

            last_y = y
            if a - x * y > 0:
                char = "+"
            else:
                char = "-"
            if y < 0:
                y *= -1
                char2 = "-"
            else:
                char2 = "+"

            result += "+" * x + "[>" + char2 * y + "<-]>" + char * abs(a - x * last_y) + ".<"

        p += a

    return result


def execute(code, i=0, p=0, memory=0):
    """
    a little brainfuck interpreter to run the code generated by string_to_bf function
    """
    if memory == 0:
        memory = [0 for i in range(MEMORY_SIZE)]
    code_len = len(code)  # to evaluate only one time
    while i < code_len:
        if code[i] == "[":
            while memory[p] != 0:
                p = execute(code, i+1, p, memory)
            while code[i] != "]":
                i += 1

        elif code[i] == "]":
            return p

        elif code[i] == ">":
            p += 1

        elif code[i] == "<":
            p -= 1

        elif code[i] == "+":
            memory[p] += 1

        elif code[i] == "-":
            memory[p] -= 1

        elif code[i] == ".":
            print(chr(memory[p]), end="")

        elif code[i] == ",":
            char = input()
            if len(char) == 0:
                memory[p] = 0
            else:
                memory[p] = ord(char[0])
        i += 1


if __name__ == "__main__":
    string = input("string: ")
    bf_code = string_to_bf(string)

    print(bf_code, "\n\n")

    execute(bf_code)  # to see that it works good